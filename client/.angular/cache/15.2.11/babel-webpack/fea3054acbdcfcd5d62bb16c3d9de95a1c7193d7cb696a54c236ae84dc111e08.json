{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-10-registration-login-example-accounts';\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      return handleRoute();\n      function handleRoute() {\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      }\n      // route functions\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\n        if (!account) return error('Email or password is incorrect');\n        // add refresh token to account\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized();\n        // replace old refresh token with a new one and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(Object.assign(Object.assign({}, basicDetails(account)), {\n          jwtToken: generateJwtToken(account)\n        }));\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        // revoke token and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered message in alert\n          setTimeout(() => {\n            alertService.info(`\n                        <h4>Email Already Registered</h4>\n                        <p>Your email ${account.email} is already registered.</p>\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                        <div>\n                        <strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.\n                        </div>\n                    `, {\n              autoclose: false\n            });\n          }, 1000);\n          // always return ok() response to prevent email enumeration\n          return ok();\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.role = Role.Admin;\n        } else {\n          account.role = Role.User;\n        }\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.isVerified = false;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display verification email in alert\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          alertService.info(`\n                    <h4>Verification Email</h4>\n                    <p>Thanks for registering!</p>\n                    <p>Please click the below link to verify your email address:</p>\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoclose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        // set is verified flag to true if token is valid\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        // always return ok() response to prevent email enumeration\n        if (!account) return ok();\n        // create reset token that expires after 24 hours\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display password reset email in alert\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                    <h4>Reset Password Email</h4>\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error(\"Invalid token\");\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        // update password and remove reset token\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can get own profile and admin accounts can get all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        return ok(basicDetails(account));\n      }\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          return error(`Email ${account.email} is already registered`);\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id == idFromUrl());\n        // user accounts can update own profile and admin accounts can update all profiles\n        if (account.id != currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // only update password if included\n        if (!params.password) {\n          delete params.password;\n        }\n        // don't save confirm password\n        delete params.confirmPassword;\n        // update and save account\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok(basicDetails(account));\n      }\n      function deleteAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can delete own account and admin accounts can delete any account\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // delete account then save\n        accounts = accounts.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      // helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500)); // delay observable to simulate server api call\n      }\n\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n        // call materialize and dematerialize to ensure delay even if an error is thrown\n      }\n\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified\n        };\n      }\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n      function isAuthorized(role) {\n        const account = currentAccount();\n        if (!account) return false;\n        return account.role === role;\n      }\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n      function currentAccount() {\n        // check if jwt token is in auth header\n        const authHeader = headers.get('Authorization');\n        if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\n        // check if token is expired\n        const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n        const tokenExpired = Date.now() > jwtToken.exp * 1000;\n        if (tokenExpired) return;\n        const account = accounts.find(x => x.id === jwtToken.id);\n        return account;\n      }\n      function generateJwtToken(account) {\n        // create token that expires in 15 minutes\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString();\n        // add token cookie that expires in 7 days\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n      function getRefreshToken() {\n        // get refresh token from cookie\n        return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n      }\n    }\n  }\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n  };\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport let fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":{"version":3,"mappings":"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","names":["HttpResponse","HTTP_INTERCEPTORS","of","throwError","delay","materialize","dematerialize","Role","accountsKey","accounts","JSON","parse","localStorage","getItem","FakeBackendInterceptor","constructor","alertService","intercept","request","next","url","method","headers","body","handleRoute","endsWith","authenticate","refreshToken","revokeToken","register","verifyEmail","forgotPassword","validateResetToken","resetPassword","getAccounts","match","getAccountById","createAccount","updateAccount","deleteAccount","handle","email","password","account","find","x","isVerified","error","refreshTokens","push","generateRefreshToken","setItem","stringify","ok","basicDetails","jwtToken","generateJwtToken","getRefreshToken","unauthorized","includes","filter","isAuthenticated","setTimeout","info","location","origin","autoclose","id","newAccountId","role","Admin","User","dateCreated","Date","toISOString","verificationToken","getTime","toString","confirmPassword","verifyUrl","token","resetToken","resetTokenExpires","now","resetUrl","autoClose","map","idFromUrl","currentAccount","isAuthorized","params","Object","assign","status","pipe","message","title","firstName","lastName","urlParts","split","parseInt","length","Math","max","authHeader","get","startsWith","atob","tokenExpired","exp","tokenPayload","round","btoa","expires","toUTCString","document","cookie","factory","fakeBackendProvider","provide","useClass","multi"],"sourceRoot":"","sources":["D:\\user-management-system\\client\\src\\app\\_helpers\\fake-backend.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HttpInterceptor, HTTP_INTERCEPTORS, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\r\n\r\nimport { AlertService } from '@app/_services';\r\nimport { Role } from '@app/_models';\r\n\r\n// array in local storage for accounts\r\nconst accountsKey = 'angular-10-registration-login-example-accounts';\r\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\r\n\r\n@Injectable()\r\nexport class FakeBackendInterceptor implements HttpInterceptor {\r\n    constructor(private alertService: AlertService) { }\r\n\r\n    intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\r\n        const { url, method, headers, body } = request;\r\n        const alertService = this.alertService;\r\n\r\n        return handleRoute();\r\n\r\n        function handleRoute() {\r\n            switch (true) {\r\n                case url.endsWith('/accounts/authenticate') && method === 'POST':\r\n                    return authenticate();\r\n                case url.endsWith('/accounts/refresh-token') && method === 'POST':\r\n                    return refreshToken();\r\n                case url.endsWith('/accounts/revoke-token') && method === 'POST':\r\n                    return revokeToken();\r\n                case url.endsWith('/accounts/register') && method === 'POST':\r\n                    return register();\r\n                case url.endsWith('/accounts/verify-email') && method === 'POST':\r\n                    return verifyEmail();\r\n                case url.endsWith('/accounts/forgot-password') && method === 'POST':\r\n                    return forgotPassword();\r\n                case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\r\n                    return validateResetToken();\r\n                case url.endsWith('/accounts/reset-password') && method === 'POST':\r\n                    return resetPassword();\r\n                case url.endsWith('/accounts') && method === 'GET':\r\n                    return getAccounts();\r\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\r\n                    return getAccountById();\r\n                case url.endsWith('/accounts') && method === 'POST':\r\n                    return createAccount();\r\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\r\n                    return updateAccount();\r\n                case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\r\n                    return deleteAccount();\r\n                default:\r\n                    // pass through any requests not handled above\r\n                    return next.handle(request);\r\n            }\r\n        }\r\n\r\n        // route functions\r\n        function authenticate() {\r\n            const { email, password } = body;\r\n            const account = accounts.find(x => x.email === email && x.password === password && x.isVerified);\r\n\r\n            if (!account) return error('Email or password is incorrect');\r\n\r\n            // add refresh token to account\r\n            account.refreshTokens.push(generateRefreshToken());\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok({\r\n                ...basicDetails(account),\r\n                jwtToken: generateJwtToken(account)\r\n            });\r\n        }\r\n\r\n        function refreshToken() {\r\n            const refreshToken = getRefreshToken();\r\n\r\n            if (!refreshToken) return unauthorized();\r\n\r\n            const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\r\n\r\n            if (!account) return unauthorized();\r\n\r\n            // replace old refresh token with a new one and save\r\n            account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\r\n            account.refreshTokens.push(generateRefreshToken());\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok({\r\n                ...basicDetails(account),\r\n                jwtToken: generateJwtToken(account)\r\n            });\r\n        }\r\n\r\n        function revokeToken() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            const refreshToken = getRefreshToken();\r\n            const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\r\n\r\n            // revoke token and save\r\n            account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function register() {\r\n            const account = body;\r\n\r\n            if (accounts.find(x => x.email === account.email)) {\r\n                // display email already registered message in alert\r\n                setTimeout(() => {\r\n                    alertService.info(`\r\n                        <h4>Email Already Registered</h4>\r\n                        <p>Your email ${account.email} is already registered.</p>\r\n                        <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\r\n                        <div>\r\n                        <strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.\r\n                        </div>\r\n                    `, { autoclose: false });\r\n                }, 1000);\r\n\r\n                // always return ok() response to prevent email enumeration\r\n                return ok();\r\n            }\r\n\r\n            // assign account id and a few other properties then save\r\n            account.id = newAccountId();\r\n            if (account.id === 1) {\r\n                // first registered account is an admin\r\n                account.role = Role.Admin;\r\n            } else {\r\n                account.role = Role.User;\r\n            }\r\n            account.dateCreated = new Date().toISOString();\r\n            account.verificationToken = new Date().getTime().toString();\r\n            account.isVerified = false;\r\n            account.refreshTokens = [];\r\n            delete account.confirmPassword;\r\n            accounts.push(account);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            // display verification email in alert\r\n            setTimeout(() => {\r\n                const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\r\n                alertService.info(`\r\n                    <h4>Verification Email</h4>\r\n                    <p>Thanks for registering!</p>\r\n                    <p>Please click the below link to verify your email address:</p>\r\n                    <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\r\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\r\n                `, { autoclose: false });\r\n            }, 1000);\r\n\r\n            return ok();\r\n        }\r\n\r\n        function verifyEmail() {\r\n            const { token } = body;\r\n            const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\r\n\r\n            if (!account) return error('Verification failed');\r\n\r\n            // set is verified flag to true if token is valid\r\n            account.isVerified = true;\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function forgotPassword() {\r\n            const { email } = body;\r\n            const account = accounts.find(x => x.email === email);\r\n\r\n            // always return ok() response to prevent email enumeration\r\n            if (!account) return ok();\r\n\r\n            // create reset token that expires after 24 hours\r\n            account.resetToken = new Date().getTime().toString();\r\n            account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            // display password reset email in alert\r\n            setTimeout(() => {\r\n                const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\r\n                alertService.info(`\r\n                    <h4>Reset Password Email</h4>\r\n                    <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\r\n                    <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\r\n                    <div><strong>NOTE:</strong> The fake backend displayed this \"email\" so you can test without an API. A real backend would send a real email.</div>\r\n                `, { autoClose: false });\r\n            }, 1000);\r\n\r\n            return ok();\r\n        }\r\n\r\n        function validateResetToken() {\r\n            const { token } = body;\r\n            const account = accounts.find(x =>\r\n                !!x.resetToken &&\r\n                x.resetToken === token &&\r\n                new Date() < new Date(x.resetTokenExpires)\r\n            );\r\n\r\n            if (!account) return error(\"Invalid token\");\r\n\r\n            return ok();\r\n        }\r\n\r\n        function resetPassword() {\r\n            const { token, password } = body;\r\n            const account = accounts.find(x =>\r\n                !!x.resetToken && x.resetToken === token &&\r\n                new Date() < new Date(x.resetTokenExpires)\r\n            );\r\n\r\n            if (!account) return error('Invalid token');\r\n\r\n            // update password and remove reset token\r\n            account.password = password;\r\n            account.isVerified = true;\r\n            delete account.resetToken;\r\n            delete account.resetTokenExpires;\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n\r\n        }\r\n\r\n        function getAccounts() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n            return ok(accounts.map(x => basicDetails(x)));\r\n        }\r\n\r\n        function getAccountById() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            let account = accounts.find(x => x.id === idFromUrl());\r\n\r\n            // user accounts can get own profile and admin accounts can get all profiles\r\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\r\n                return unauthorized();\r\n            }\r\n\r\n            return ok(basicDetails(account));\r\n\r\n        }\r\n\r\n        function createAccount() {\r\n            if (!isAuthorized(Role.Admin)) return unauthorized();\r\n\r\n            const account = body;\r\n            if (accounts.find(x => x.email === account.email)) {\r\n                return error(`Email ${account.email} is already registered`);\r\n            }\r\n\r\n            // assign account id and a few other properties then save\r\n            account.id = newAccountId();\r\n            account.dateCreated = new Date().toISOString();\r\n            account.isVerified = true;\r\n            account.refreshTokens = [];\r\n            delete account.confirmPassword;\r\n            accounts.push(account);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        function updateAccount() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            let params = body;\r\n            let account = accounts.find(x => x.id == idFromUrl());\r\n\r\n            // user accounts can update own profile and admin accounts can update all profiles\r\n            if (account.id != currentAccount().id && !isAuthorized(Role.Admin)) {\r\n                return unauthorized();\r\n            }\r\n\r\n            // only update password if included\r\n            if (!params.password) {\r\n                delete params.password;\r\n            }\r\n            // don't save confirm password\r\n            delete params.confirmPassword;\r\n\r\n            // update and save account\r\n            Object.assign(account, params);\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok(basicDetails(account));\r\n        }\r\n\r\n        function deleteAccount() {\r\n            if (!isAuthenticated()) return unauthorized();\r\n\r\n            let account = accounts.find(x => x.id === idFromUrl());\r\n\r\n            // user accounts can delete own account and admin accounts can delete any account\r\n            if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\r\n                return unauthorized();\r\n            }\r\n\r\n            // delete account then save\r\n            accounts = accounts.filter(x => x.id !== idFromUrl());\r\n            localStorage.setItem(accountsKey, JSON.stringify(accounts));\r\n\r\n            return ok();\r\n        }\r\n\r\n        // helper functions\r\n        function ok(body?) {\r\n            return of(new HttpResponse({ status: 200, body }))\r\n                .pipe(delay(500)); // delay observable to simulate server api call\r\n        }\r\n\r\n        function error(message) {\r\n            return throwError({ error: { message } })\r\n                .pipe(materialize(), delay(500), dematerialize());\r\n            // call materialize and dematerialize to ensure delay even if an error is thrown\r\n        }\r\n\r\n        function unauthorized() {\r\n            return throwError({ status: 401, error: { message: 'Unauthorized' } })\r\n                .pipe(materialize(), delay(500), dematerialize());\r\n        }\r\n\r\n        function basicDetails(account) {\r\n            const { id, title, firstName, lastName, email, role, dateCreated, isVerified } = account;\r\n            return { id, title, firstName, lastName, email, role, dateCreated, isVerified };\r\n        }\r\n\r\n        function isAuthenticated() {\r\n            return !!currentAccount();\r\n        }\r\n\r\n        function isAuthorized(role) {\r\n            const account = currentAccount();\r\n            if (!account) return false;\r\n            return account.role === role;\r\n        }\r\n\r\n        function idFromUrl() {\r\n            const urlParts = url.split('/');\r\n            return parseInt(urlParts[urlParts.length - 1]);\r\n        }\r\n\r\n        function newAccountId() {\r\n            return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\r\n        }\r\n\r\n        function currentAccount() {\r\n            // check if jwt token is in auth header\r\n            const authHeader = headers.get('Authorization');\r\n            if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\r\n\r\n            // check if token is expired\r\n            const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\r\n            const tokenExpired = Date.now() > (jwtToken.exp * 1000);\r\n            if (tokenExpired) return;\r\n\r\n            const account = accounts.find(x => x.id === jwtToken.id);\r\n            return account;\r\n        }\r\n\r\n        function generateJwtToken(account) {\r\n            // create token that expires in 15 minutes\r\n            const tokenPayload = {\r\n                exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\r\n                id: account.id\r\n            };\r\n            return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\r\n        }\r\n\r\n        function generateRefreshToken() {\r\n            const token = new Date().getTime().toString();\r\n\r\n            // add token cookie that expires in 7 days\r\n            const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\r\n            document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\r\n            return token;\r\n        }\r\n\r\n        function getRefreshToken() {\r\n            // get refresh token from cookie\r\n            return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\r\n        }\r\n    }\r\n}\r\n\r\nexport let fakeBackendProvider = {\r\n    // use fake backend in place of Http service for backend-less development\r\n    provide: HTTP_INTERCEPTORS,\r\n    useClass: FakeBackendInterceptor,\r\n    multi: true\r\n};"]},"metadata":{},"sourceType":"module","externalDependencies":[]}